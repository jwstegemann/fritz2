package io.fritz2.optics


import com.squareup.kotlinpoet.*
import de.jensklingenberg.mpapt.common.*
import de.jensklingenberg.mpapt.model.AbstractProcessor
import de.jensklingenberg.mpapt.model.Element
import de.jensklingenberg.mpapt.model.RoundEnvironment
import de.jensklingenberg.mpapt.utils.KonanTargetValues
import de.jensklingenberg.mpapt.utils.KotlinPlatformValues
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.resolve.annotations.argumentValue
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import java.io.File
import io.fritz2.optics.Optics

class MpAptTestProcessor() : AbstractProcessor() {
    val TAG = "MyAnnotationProcessor"

    val get = Optics::class.java.name
    val getFunctions = mutableListOf<FunctionDescriptor>()

    override fun process(roundEnvironment: RoundEnvironment) {

        roundEnvironment.getElementsAnnotatedWith(get).forEach { element ->
            when (element) {
                is Element.FunctionElement -> {
                    getFunctions.add(element.func)
                }
            }
        }


    }

    override fun isTargetPlatformSupported(platform: TargetPlatform): Boolean {
        val targetName = platform.first().platformName

        return when (targetName) {
            KotlinPlatformValues.JS -> true
            KotlinPlatformValues.JVM -> false
            else -> {
                log(targetName)
                false
            }
        }

    }

    override fun getSupportedAnnotationTypes(): Set<String> = setOf(get)

    override fun processingOver() {
        log("$TAG***Processor over ***")

        val getFunSpecs = getFunctions
                .map { function ->
                    FunSpec.builder(function.simpleName()).apply {
                        when (function.isSuspend) {
                            true -> addModifiers(KModifier.SUSPEND)
                        }
                    }
                            .addModifiers(KModifier.OVERRIDE)
                            .addParameters(
                                    function.getFunctionParameters().map {
                                        ParameterSpec.builder(
                                                it.parameterName,
                                                ClassName(it.packagee.packagename, it.packagee.classname)
                                        ).build()
                                    }

                            )
                            .returns(ClassName("", function.getReturnTypeImport().toString()))
                            .addStatement("return client.get(baseUrl+${function.annotations.first().argumentValue("url")})")
                            .build()
                }


        val file = FileSpec.builder(getFunctions.first().containingDeclaration.containingDeclaration?.fqNameSafe?.asString()
                ?: "", "KtorfitApi")
                .addComment("GENERATED by KtorFit")
                .apply {
                    if (getFunctions.isNotEmpty()) {
                        addImport("io.ktor.client.request.get", "")
                    }
                }
                .addType(
                        TypeSpec.classBuilder(ClassName(getFunctions.first().containingDeclaration.containingDeclaration?.fqNameSafe?.asString()
                                ?: "", "KtorfitApi"))
                                .primaryConstructor(FunSpec.constructorBuilder()
                                        .addParameter("baseUrl", String::class)
                                        .build())
                                .addProperty(PropertySpec.builder("client", ClassName("io.ktor.client", "HttpClient")).initializer("HttpClient()").build())
                                .addProperty(PropertySpec.builder("baseUrl", String::class).initializer("baseUrl").build())

                                .addSuperinterface(
                                        ClassName(
                                                getFunctions.first().containingDeclaration.containingDeclaration?.fqNameSafe?.asString()
                                                        ?: "",
                                                "Api"
                                        )
                                )
                                .addFunctions(getFunSpecs)

                                .addFunction(
                                        FunSpec.builder("create")
                                                .addCode(
                                                        """
        |return this
        |""".trimMargin()


                                                ).returns(ClassName("", "Api")).build()
                                )


                                // .addFunctions(postFuncs)
                                .build()
                )


                .build()
        val filepath = (getFunctions.first().containingDeclaration as ClassDescriptor).guessingSourceSetFolder()
        file.writeTo(File(filepath))


    }

}
